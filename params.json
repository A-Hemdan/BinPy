{"name":"BinPy","tagline":"Virtualizing Electronics","body":"What is BinPy?\r\n---------------\r\nThis package will serve as a base to develop circuit based applications or logical games on top of it. \r\nThis package does not depend on any external library other than pure Python.\r\n\r\nHow to use\r\n----------\r\n\r\nHere's an example of SR latch constructed from a pair of cross-coupled NOR gates\r\n![SR latch | Source: Wikipedia](https://upload.wikimedia.org/wikipedia/commons/c/c6/R-S_mk2.gif)\r\n\r\n```python\r\nfrom BinPy import *\r\n\r\nNOR1 = Nor('NOR1')  #First NOR gate\r\nNOR2 = Nor('NOR2')  #Second NOR gate\r\n\r\nNOR2.C.connect(NOR1.B)  #Connecting output of second NOR with input of first NOR\r\nNOR1.C.connect(NOR2.A)  #Connecting output of first NOR with input of second NOR\r\n\r\n\r\nNOR1.A.set(1);NOR2.B.set(0)\t#Set state\r\nprint 'Q: ',NOR2.C.getState(), '\\t','Q\\': ',NOR1.C.getState()\r\n\r\n\r\nNOR1.A.set(0);NOR2.B.set(1)\t#Reset state\r\nprint 'Q: ',NOR2.C.getState(), '\\t','Q\\': ',NOR1.C.getState()\r\n\r\n\r\nNOR1.A.set(0);NOR2.B.set(0)\t#Hold state\r\nprint 'Q: ',NOR2.C.getState(), '\\t','Q\\': ',NOR1.C.getState()\r\n\r\n\r\nNOR1.A.set(1);NOR2.B.set(1)\t#Invalid state\r\nprint 'Q: ',NOR2.C.getState(), '\\t','Q\\': ',NOR1.C.getState()\r\n```\r\n\r\n<strong>Output</strong>\r\n```python\r\nQ:  True \tQ':  False\r\nQ:  False \tQ':  True\r\nQ:  False \tQ':  True\r\nQ:  False \tQ':  False\r\n```\r\n<strong>Operations, Combinatonal Logic and Algorithms</strong>\r\n\r\n```python\r\nfrom BinPy import *\r\n\r\n#Operations\r\noperator = Operation()\r\nprint operator.add([1,0,1,1],[1,1])\r\nprint operator.subtract([1,0,1,1],[1,1])\r\n\r\n#Combinational Logic\r\nmyMUX = MUX()\r\nprint \"MUX Out: \", myMUX.run([1,0,0,0,1,1,1,1],[0,0,1])\r\n\r\n#Algorithms \r\n#Includes the Quine-McCluskey algorithm for solving K-Maps\r\nFinalEquation = QM(['A','B'])\r\nprint \"Minimized Boolean Equation : \" , FinalEquation.get_function(qm.solve([0,1,2],[])[1])\r\n\r\n\r\n#IC\r\nmyIC = IC_7400()\r\np = {1:1,2:0,4:0,5:0,7:0,10:1,9:1,13:0,12:0,14:1}\r\nmyIC.setIC(p)\r\nprint \"IC_7400 Out: \", myIC.run()\r\n\r\nmyIC1 = IC_7401()\r\np = {2:0,3:1,5:0,6:0,7:0,8:1,9:1,11:0,12:0,14:1}\r\nmyIC1.setIC(p)\r\nprint \"IC_7401 Out: \", myIC1.run()\r\n```\r\n<strong>Output</strong><br/>\r\n```python\r\n{'carry': 0, 'sum': [1, 1, 1, 0]}\r\n{'carry': 1, 'difference': [1, 0, 0, 0]}\r\nMUX Out:  0\r\nIC_7400 Out:  {8: 0, 11: 1, 3: 1, 6: 1}\r\nIC_7401 Out:  {1: 1, 10: 0, 4: 1, 13: 1}\r\nMinimized Boolean Equation : ((NOT B) OR (NOT A))\r\n```\r\nAvailable Resources\r\n-------------------\r\n* All basic logic gates (NOT, OR, NOR, AND, NAND, XOR, XNOR)\r\n* Combinational logics\r\n\t* Adder\r\n\t* Subtractor\r\n\t* Multiplier\r\n\t* MUX (2:1, 4:1, 8:1, 16:1)\r\n\t* DEMUX (1:2, 1:4, 1:8, 1:16)\r\n\t* Encoder\r\n\t\r\n* IC\r\n\t* 7400\r\n\t* 741G00\r\n\t* 7401\r\n\t* 7402\r\n\t* 741G02\r\n\t* 7403\r\n\t* 741G03\r\n\t* 7404\r\n\t* 741G04\r\n\t* 7405\r\n\t* 741G05\r\n\t* 7408\r\n\t* 741G08\r\n\t* 7410\r\n\t* 7411\r\n\t* 7442\r\n\t* 7443\r\n\t* 7444\r\n\t* 7451\r\n\t* 7454\r\n\t* 7455\r\n\t* 7458\r\n* Algorithms\r\n\t* Quine-McCluskey Algorithm (To find minimized Boolean Equation)\r\n\t* Moore Machine Optimizer\r\n\r\nFuture Works\r\n------------\r\n* Introduction of all ICs\r\n* Introduction of problem solving algorithms\r\n* Addition of Microprocessors and Analog Devices\r\n* Graphical representation of the circuit\r\n* ...\r\n","google":"UA-43949546-1","note":"Don't delete this file! It's used internally to help with page regeneration."}